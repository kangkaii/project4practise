package kk.practice.javaStackQueue;import java.io.Serializable;import java.util.NoSuchElementException;/** * @author kangkai on 2018/11/9. * 1 front为队头元素的下标，rear则指向下一个入队元素的下标 * 2 当front=rear时，我们约定队列为空。 * 3 出队操作改变front下标指向，入队操作改变rear下标指向，size代表队列容量。 * 4 约定队列满的条件为front=(rear+1)%size,注意此时队列中仍有一个空的位置，此处留一个空位主要用于避免与队列空的条件front=rear相同。 * 5 队列内部的数组可扩容，并按照原来队列的次序复制元素数组 */public class SeqQueue<T> implements Queue<T>,Serializable {    private static final long serialVersionUID = -1664818681270068094L;    private static final int  DEFAULT_SIZE = 10; //默认大小10    private T[] elementData;    //front 队头    //rear 队尾    private int front,rear;    //记录元素个数    private int size;    public SeqQueue () {        elementData = (T[]) new Object[DEFAULT_SIZE];        front=rear=0;    }    public SeqQueue (int capacity) {        elementData = (T[]) new Object[capacity];        front=rear=0;    }    @Override    public int size() {        return this.size;    }    @Override    public boolean isEmpty() {        return front==rear;    }    @Override    public boolean add(T data) {        //判断是否需要扩容        if (this.front==(this.rear+1)%this.elementData.length){            ensureCapacity(elementData.length*2+1);        }        elementData[this.rear] = data;        this.rear = (this.rear+1)%elementData.length;        return false;    }    private void ensureCapacity(int capacity) {        //简单校验        if (capacity<size) {            return;        }        T[] old = this.elementData;        this.elementData = (T[])new Object[capacity];        //数组的复制        int j = 0;//新数组 从0开始        for(int i = this.front; i != this.rear; i=(i+1)%old.length,j++) {            elementData[j] = old[i];        }        //恢复front,rear指向        this.front = 0;        this.rear = j;    }    /**     * 插入元素时候     * 1 元素为空 抛异常     * 2 队满 抛异常     */    @Override    public boolean offer(T data) {        if (null == data) {            throw new NullPointerException("The data can\'t be null");        }        if (this.front==(rear+1)%this.elementData.length) {            throw new IllegalArgumentException("The capacity of SeqQueue has reached its maximum");        }        this.elementData[rear] = data;        size++;        //更新rear指向下一个空元素的位置        this.rear=(this.rear+1)%elementData.length;        return true;    }    /**     * 返回队头元素,不执行删除操作,若队列为空,返回null     */    @Override    public T peek() {        return elementData[front];    }    /**     * 返回队头元素,不执行删除操作,若队列为空,抛出异常:NoSuchElementException     */    @Override    public T element() {        if(isEmpty()){            throw new NoSuchElementException("The SeqQueue is empty");        }        return peek();    }    @Override    public T poll() {//出队        T temp = this.elementData[front];        this.elementData[front] = null;//删除        this.front = (this.front+1)%(this.elementData.length);        this.size--;        return temp;    }    /**     * 出队,执行删除操作,若队列为空,抛出异常:NoSuchElementException     */    @Override    public T remove() {        if (isEmpty()){            throw new NoSuchElementException("The SeqQueue is empty");        }        return poll();    }    /**     * 清除所有元素 + 指针归0     */    @Override    public void clearQueue() {        for (int i = this.front;i!=this.rear; i = (i+1)%this.elementData.length) {            elementData[i] = null;        }        //复位        this.front = this.rear = 0;        size=0;    }}