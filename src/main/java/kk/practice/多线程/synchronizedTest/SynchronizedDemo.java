package kk.practice.多线程.synchronizedTest;/** * synchronized 修饰对象与类的差别 * @author kangkai on 2018/11/23. */public class SynchronizedDemo implements Runnable{    private int count = 0;    public SynchronizedDemo() {count = 0;}    @Override    public void run() {        synchronized (this) {//this 锁住的是对象，SynchronizedDemo.class 锁住的是类（invoke02在锁住对象的情况下，使用2个对象创建线程，导致锁失效）            for (int i = 0; i < 5; i++) {                String threadName = Thread.currentThread().getName();                System.out.println(threadName + " : " + count++);                try {                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    /**     * 调用方式1：一个对象调用     */    private static void invoke () {        SynchronizedDemo synchronizedDemo = new SynchronizedDemo();        Thread thread01 = new Thread(synchronizedDemo,"thread-001");        Thread thread02 = new Thread(synchronizedDemo,"thread-002");        thread01.start();        thread02.start();    }    /**     * 调用方式2：2个对象调用     */    private static void invoke02 () {        Thread thread01 = new Thread(new SynchronizedDemo(),"thread-001");        Thread thread02 = new Thread(new SynchronizedDemo(),"thread-002");        thread01.start();        thread02.start();    }    public static void main(String[] args) {        invoke();//        invoke02();    }}